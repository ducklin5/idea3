/**
  Copyright 2017 by Satya Mallick ( Big Vision LLC )
http://www.learnopencv.com
 **/

#include <opencv2/opencv.hpp>
#include <vector>
#include <set>
#include <map>

using namespace std;
using namespace cv;

void usefulCode(){
	//	Mat channels[3];
	//	split(orig, channels);



	//	Mat green = orig.clone();
	//	for (int i = 0; i < green.rows; i++){
	//		for (int j = 0; j < green.cols; j++){
	//			auto bgr = green.at<Vec3b>(i,j).val;
	//			bgr[0] = 0;
	//			bgr[1] = (bgr[1] < 128 ) * 255;
	//			bgr[2] = 0;
	//		}
	//	}

}

Mat threshold (Mat img, int radius) {
	Mat outImg(img.size(), CV_8UC1);
	// for each pixel
	for (int y = 0; y < img.rows; y++){
		for (int x = 0; x < img.cols; x++){
			//cout << "( " << x << ", " << y << ") "; 
			//cout << " out of : ";
			//cout << "( " << img.cols << ", " << img.rows << ")\n"; 
			// get the average value of surrounding pixels
			int avg = 0;
			int count = 0;

			// loop through surrounding pixels
			for(int j = -radius; j <= radius; j++){
				if(y+j < 0 or y+j >= img.rows) continue; // next if the neighbor doesnt exit (y)
				for(int i = -radius; i <= radius; i++){
					if(x+i < 0 or x+i >= img.rows) continue; // next if the neighbor doesnt exit (x)

					avg += img.at<uchar>(y+j,x+i);
					count ++;
				}
			}
			avg /= count;

			outImg.at<uchar>(y,x) = (img.at<uchar>(y, x) < avg * 0.9) * 255;

		}
	}

	return outImg;
}


Mat blobExtract( Mat binImg ){
	Mat blobImg(binImg.size(), CV_32SC1, Scalar(0));
	int label = 0;
	map <int,set<int>> labelEqvs;

	for (int y = 0; y < binImg.rows; y++){
		for (int x = 0; x < binImg.cols; x++){
			uchar& currentPx = binImg.at<uchar>(y,x);
			int& currentLabel = blobImg.at<int>(y,x);

			if( currentPx >  0 ){
				// intialize variable to store top and left data (-1 means never set)
				int top = -1;
				int left = -1;
				// if the top/left exists, then get its value from binImg
				if ( y > 0 ) top = binImg.at<uchar>(y-1, x);
				if ( x > 0 ) left = binImg.at<uchar>(y, x-1);
				// if they both are not foreground pixels
				if (top <= 0 and left <= 0) {
					label+= 1;
					currentLabel = label;
					// otherwise at least one of them is foreground
				} else {
					// if the top is foreground, then set the current label to its label
					int toplbl = 0;
					int leftlbl = 0;
					if ( top > 0 ) {
						toplbl = blobImg.at<int>(y-1, x);
						currentLabel = toplbl;
					}
					if ( left > 0 ){
						leftlbl = blobImg.at<int>(y, x-1);
						currentLabel = blobImg.at<int>(y, x-1);
					}
					// if they both are foreground
					if ( top > 0 and left > 0 and toplbl != leftlbl ){
						// set the label to the lowest one and record the conflict
						currentLabel = ( toplbl < leftlbl ? toplbl: leftlbl);
						labelEqvs[toplbl].insert(leftlbl);
						labelEqvs[leftlbl].insert(toplbl);
					}
				}
			}
			cout << "label: " << label << endl;
		}
	}

//	for (auto const& eqv : labelEqvs)
//	{
//		cout << eqv.first << ':';
//		for (auto const& lbl : eqv.second){
//			cout << lbl << ", ";
//		}
//		cout << std::endl ;
//	}
//
	set<int> remaining;
	for (int y = 0; y < blobImg.rows; y++){
		for (int x = 0; x < blobImg.cols; x++){
			int& currentLabel = blobImg.at<int>(y,x);
			// get the first element of the set/ the lowest equivalent
			currentLabel = *labelEqvs[currentLabel].begin();
			remaining.insert(currentLabel);
		}
	}
	cout << remaining.size() << " labels\n";;
	return blobImg;
}

int main(int argc, char** argv )
{
	// Read image
	Mat orig = imread(argv[1], IMREAD_COLOR );

	Mat gray;
	cvtColor(orig, gray, CV_RGB2GRAY);

	// radiud based thersholding
	Mat black = threshold(gray, 2);
	Mat blobbed = blobExtract(black);

	// blob extraction - https://en.wikipedia.org/wiki/Connected-component_labeling
	// graph theory

	imshow("Orig", orig);
	imshow("Gray", gray);
	imshow("B&W", black);
	imshow("Blobbed", blobbed);
	waitKey(0);

}
